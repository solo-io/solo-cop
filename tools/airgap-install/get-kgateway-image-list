#!/usr/bin/env bash

set -Eeuo pipefail
trap cleanup SIGINT SIGTERM ERR EXIT

script_name=$(basename "${BASH_SOURCE[0]}")
script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)

# default values of variables set from params
version=""
chart_repo="oci://us-docker.pkg.dev/solo-public/gloo-gateway/charts"
pull=false
retain_images=false
skip_crds=false
validate_image_repo=false

usage() {
    cat <<EOF
Usage: $script_name [-h] version

This script will print out the list of images required for an air-gapped installation of Solo Enterprise for kgateway.
The version argument is required.

Available options:

-cr, --chart-repo      Chart repository (Defaults to oci://us-docker.pkg.dev/solo-public/gloo-gateway/charts if not specified)
-p,  --pull            Execute a Docker pull
-r,  --retain          Retain '.images.out' at the end of the run and dont purge it
-sc, --skip-crds        Skip CRDs chart (By default it will process all charts)
-v,  --validate        Validate the discovered Docker repositories
-d,  --debug            Print script debug info
-h,  --help             Print help and exit
EOF
    exit
}

cleanup() {
    trap - SIGINT SIGTERM ERR EXIT
    # nothing to do
    if [[ -z $version ]]; then
        return
    fi
    rm -f *.tgz
    rm -rf helm || true
    rm -rf enterprise-kgateway || true
    if [[ "$retain_images" == false ]]; then
        rm -f .images.out
    fi
}

setup_colors() {
    if [[ -t 2 ]] && [[ -z "${NO_COLOR-}" ]] && [[ "${TERM-}" != "dumb" ]]; then
        NOFORMAT='\033[0m' RED='\033[0;31m' GREEN='\033[0;32m' ORANGE='\033[0;33m' BLUE='\033[0;34m' PURPLE='\033[0;35m' CYAN='\033[0;36m' YELLOW='\033[1;33m'
    else
        NOFORMAT='' RED='' GREEN='' ORANGE='' BLUE='' PURPLE='' CYAN='' YELLOW=''
    fi
}

msg() {
    echo >&2 -e "${1-}"
}

die() {
    local msg=$1
    local code=${2-1} # default exit status 1
    msg "$msg"
    exit "$code"
}

parse_params() {
    local args=("$@")

    while :; do
        case "${1-}" in 
        -d  | --debug) set -x ;;
        -h  | --help) usage ;;
        -cr | --chart-repo) shift && chart_repo=$1 ;;
        -sc | --skip-crds) skip_crds=true ;;
        -p  | --pull) pull=true ;;
        -r  | --retain) retain_images=true ;;
        -v  | --validate) validate_image_repo=true ;;
        --no-color) NO_COLOR=1 ;;
        -?*) die "Unknown option: $1" ;;
        *)
            if [[ -z $version ]]; then
                version=$1
            else
                break
            fi
            ;;
        esac
        shift
    done

    # check required params and arguments
    if [[ ${#args[@]} -eq 0 || -z $version ]]; then
        die "Missing required argument - version"
    fi
    if [[ ! $version =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+(\.[0-9]+)?)?$ ]]; then
        die "Version is invalid" 
    fi

    return 0
}

# POSIX compatible
prechecks() {
    if ! command -v helm &> /dev/null; then
        die "command 'helm' not found"
    fi
    if ! command -v docker &> /dev/null; then
        die "command 'docker' not found"
    fi
    if ! command -v jq &> /dev/null; then
        die "command 'jq' not found"
    fi
    if ! command -v yq &> /dev/null; then
        die "command 'yq' not found"
    fi
    if [[ -f .images.out ]]; then
        rm -f .images.out
    fi
}

extract_images_from_values() {
    local file=$1
    # Skip if file doesn't exist or is empty
    [[ ! -f "$file" ]] && return 0
    [[ ! -s "$file" ]] && return 0
    
    # Validate YAML first - if yq can't parse it, skip it
    if ! yq eval '.' "$file" >/dev/null 2>&1; then
        return 0
    fi
    
    # Try to parse YAML and extract images, silently skip on error
    {
        yq eval $JSON_FLAG "$file" 2>/dev/null | \
        jq -r '.. | .image? | select(. != null) | 
            (if .registry then (if .registry == "docker.io" then "docker.io" else .registry end) + "/" else "" end) + 
            (if ((.repository? | tostring) != "") and has("repository") then (.repository? | tostring) 
             elif ((.repo? | tostring) != "") and has("repo") then (.repo? | tostring) 
             else (.repository? | tostring) end) + 
            ":" + (if ((.tag? | tostring) != "") and has("tag") then (.tag? | tostring) else "latest" end)' 2>/dev/null | \
        grep -v '^null:' | grep -v '^/' | grep -v '^$' | \
        grep -E '^[a-zA-Z0-9._/-]+:[a-zA-Z0-9._/-]+$' || true
    } 2>/dev/null || true
}

extract_images_from_manifests() {
    local dir=$1
    find "$dir" -type f \( -name "*.yaml" -o -name "*.yml" \) 2>/dev/null | while read file; do
        # Skip NOTES.txt, templates, and other non-manifest files
        [[ "$file" == *"NOTES.txt"* ]] && continue
        [[ "$file" == *"/templates/"* ]] && continue
        [[ ! -s "$file" ]] && continue
        
        # Validate YAML first - if yq can't parse it, skip it
        if ! yq eval '.' "$file" >/dev/null 2>&1; then
            continue
        fi
        
        # Try to parse YAML and extract images, silently skip on error
        yq eval $JSON_FLAG "$file" 2>/dev/null | \
        jq -r '.. | .image? | select(. != null and type == "string")' 2>/dev/null | \
        grep -v '^null' | grep -v '^/' | grep -v '^$' | \
        grep -E '^[a-zA-Z0-9._/-]+:[a-zA-Z0-9._/-]+$' || true
    done
}

prechecks

parse_params "$@"
setup_colors

JSON_FLAG='-o=json'

# Script logic
echo "Finding images for Solo Enterprise for kgateway version ${version}"

# Initialize images output file
touch .images.out

# Get CRDs chart
if [[ "$skip_crds" == false ]]; then
    echo ""
    echo "###################################"
    echo "# Getting CRDs chart              #"
    echo "###################################"
    if helm template --version ${version} enterprise-kgateway-crds ${chart_repo}/enterprise-kgateway-crds --output-dir ./helm > /dev/null 2>&1; then
        # Extract images from CRDs manifests (though CRDs typically don't have images, check anyway)
        if [[ -d ./helm ]]; then
            extract_images_from_manifests ./helm | sort -u | tee -a .images.out
        fi
    else
        msg "${YELLOW}Warning: Failed to template CRDs chart, continuing...${NOFORMAT}"
    fi
fi

# Get control plane chart
echo ""
echo "###################################"
echo "# Getting control plane chart     #"
echo "###################################"
if ! helm pull ${chart_repo}/enterprise-kgateway --version ${version}; then
    die "Failed to pull control plane chart"
fi

if [[ ! -f enterprise-kgateway-${version}.tgz ]]; then
    die "Chart file not found after pull"
fi

tar zxf enterprise-kgateway-${version}.tgz

# Extract images from values.yaml files
if [[ -d enterprise-kgateway ]]; then
    # Primary source: values.yaml files
    find enterprise-kgateway -type f -name "values.yaml" 2>/dev/null | while read file; do
        # Validate it's a real values.yaml file (not a template)
        if [[ "$file" == *"/templates/"* ]]; then
            continue
        fi
        extract_images_from_values "$file" 2>/dev/null
    done | sort -u | tee -a .images.out

    # Also check for images in charts subdirectories (subcharts)
    if [[ -d enterprise-kgateway/charts ]]; then
        find enterprise-kgateway/charts -type f -name "values.yaml" 2>/dev/null | while read file; do
            extract_images_from_values "$file" 2>/dev/null
        done | sort -u | tee -a .images.out
    fi
else
    die "Failed to extract control plane chart"
fi

# Remove duplicates and sort, filter out empty lines and invalid images
if [[ -f .images.out ]]; then
    grep -v '^$' .images.out | \
    grep -v '^null:' | \
    grep -v '^/' | \
    grep -E '^[a-zA-Z0-9._/-]+(:[a-zA-Z0-9._/-]+)?$' | \
    grep -v '^[[:space:]]*$' | \
    sort -u > .images.tmp && mv .images.tmp .images.out
fi

# Display summary
if [[ -f .images.out ]] && [[ -s .images.out ]]; then
    image_count=$(wc -l < .images.out | tr -d ' ')
    echo ""
    echo "###################################"
    echo "# Summary                         #"
    echo "###################################"
    echo "Found ${image_count} unique image(s) required for installation"
    echo ""
    echo "Image list:"
    cat .images.out
else
    msg "${YELLOW}Warning: No images found in charts${NOFORMAT}"
fi

if [[ "$validate_image_repo" == true ]]; then
    echo ""
    echo "Validating image repositories"
    cat .images.out | while read image; do
        if [[ -z "$image" ]]; then
            continue
        fi
        echo -n "Checking repo: $image, status: "
        if ! docker manifest inspect $image > /dev/null 2>&1; then
            echo "failed"
            echo "Invalid repository found: $image"
        else
            echo "success"
        fi
    done
fi

if [[ "$pull" == true ]]; then
    echo ""
    echo "Pulling images locally"
    cat .images.out | while read image; do
        if [[ -z "$image" ]]; then
            continue
        fi
        docker pull $image
    done
fi

# Cleanup
cleanup

